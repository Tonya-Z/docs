---
sidebar_label: Spring Boot
---

import TabItem from '@theme/TabItem';
import Tabs from '@theme/Tabs';

# Spring BootでAPIを保護する

:::note

このチュートリアルでは、管理コンソールでAPIリソース`http://localhost:3000/`を作成したことを前提としています。
準備ができていない場合は、続行する前に[こちら](./README.mdx#register-the-api-resources-using-logto-admin-console)をご覧ください。

:::

あなたのWebアプリケーションは、Spring Bootフレームワークを使用してサーバーサイドで実行される場合があります。
現時点では、Spring BootでLogtoを手動で統合する必要があります。
この記事では、その手順を段階的に案内します。
そして、例としてGradle、Java、およびSpring Securityを使用します。

## Spring Bootプロジェクトを開始する

[Spring Initializr](https://start.spring.io/)を使用して、素早くSpring Bootプロジェクトを開始できます。
次のオプションを使用してください：

- Gradleプロジェクト
- 言語：Java
- Spring Boot：2.7.2

プロジェクトを生成して開きます。

## 依存関係を追加する

Gradleプロジェクトのビルドファイル `build.gradle` に依存関係を追加します：

```groovy
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-oauth2-resource-server'
}
```

:::note

Spring BootとSpring SecurityはOAuth2リソースサーバーとJWT検証のための組込みサポートがあるため、
Logtoからの統合に追加のライブラリを追加する必要はありません。

詳細については、[Spring Security OAuth 2.0 Resource Server](https://docs.spring.io/spring-security/reference/servlet/oauth2/resource-server/index.html)および[Spring Security Architecture](https://spring.io/guides/topicals/spring-security-architecture)を参照してください。

:::

## 発行者とJWKS URIを取得する

すべてのトークンは[発行者](https://openid.net/specs/openid-connect-core-1_0.html#IssuerIdentifier)によって発行され、
[JWK](https://datatracker.ietf.org/doc/html/rfc7517)で署名されます（詳細については[JWS](https://datatracker.ietf.org/doc/html/rfc7515)を参照）。

次に進む前に、Bearer Token (`access_token`) の発行者と署名の検証に必要な発行者とJWKS URIを取得する必要があります。

デフォルトでは、Logtoの発行者およびJWKS URIは`https://<your-logto-domain>/oidc`および`https://<your-logto-domain>/oidc/jwks`です
(例：ローカル開発環境では `http://localhost:3001/oidc` および `http://localhost:3001/oidc/jwks` です)。

:::note

すべての最新のLogto Authorization Serverの設定情報は、`https://<your-logto-domain>/oidc/.well-known/openid-configuration`で確認できます
（ローカル開発環境では、 `http://localhost:3001/oidc/.well-known/openid-configuration` など）。
これには、**issuer**、**jwks_uri**、およびその他の認可の設定が含まれます。
例：

```json
{
  // ...
  "issuer": "https://<your-logto-domain>/oidc",
  "jwks_uri": "https://<your-logto-domain>/oidc/jwks"
  // ...
}
```

:::

## アプリケーションを設定する

サーバーポート、オーディエンス、およびOAuth2リソースサーバーを構成するために、`application.yml`ファイル
（デフォルトの`application.properties`ではなく）を使用します。

```yaml
# path/to/project/src/main/resources/application.yaml
server:
  port: 3000

logto:
  audience: http://localhost:3000/

spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: <your-logto-issuer-uri> # 例：http://localhost:3001/oidc
          jwk-set-uri: <your-logto-jwks-uri> # 例：http://localhost:3001/oidc/jwks
```

- `audience`:
  保護されたAPIリソースの固有のAPI識別子（つまり、API指標）。
- `spring.security.oauth2.resourceserver.jwt.issuer-uri`:
  Logtoによって発行されたJWT内の`iss`クレーム値および発行者URI。
  前のセクションから`issuer`値を入力します。
- `spring.security.oauth2.resourceserver.jwt.jwk-set-uri`:
  このURIをSpring Securityは使用して、JWTの署名を検証するための認可サーバーの公開鍵を取得します。
  前のセクションから`jwks_uri`値を入力します。

## オーディエンスバリデータを提供する

`OAuth2TokenValidator`インターフェースを実装する`AudienceValidator`クラスを提供して、
必要なオーディエンスがJWT内に存在するかを検証します。

```java
// path/to/project/src/main/java/io/logto/springboot/sample/validator/AudienceValidator.java
package io.logto.springboot.sample.validator;

import org.springframework.security.oauth2.core.OAuth2Error;
import org.springframework.security.oauth2.core.OAuth2TokenValidator;
import org.springframework.security.oauth2.core.OAuth2TokenValidatorResult;
import org.springframework.security.oauth2.jwt.Jwt;

public class AudienceValidator implements OAuth2TokenValidator<Jwt> {

    private final OAuth2Error oAuth2Error = new OAuth2Error("invalid_token", "Required audience not found", null);

    private final String audience;

    public AudienceValidator(String audience) {
        this.audience = audience;
    }

    @Override
    public OAuth2TokenValidatorResult validate(Jwt jwt) {
        if (!jwt.getAudience().contains(audience)) {
            return OAuth2TokenValidatorResult.failure(oAuth2Error);
        }

        return OAuth2TokenValidatorResult.success();
    }
}
```

:::note
[🔐 RBAC](/docs/recipes/rbac)の場合、スコープの検証も必要です。
:::

## Spring Securityを構成する

Spring Securityを使用すると、アプリケーションをリソースサーバーとして簡単に構成し、
リクエストヘッダー内のBearer TokenからJWTを検証できます。

`JwtDecoder`および`SecurityFilterChain`のインスタンスを提供し（Springビーンとして）、 `@EnableWebSecurity`アノテーションを追加する必要があります。

```java
// path/to/project/src/main/java/io/logto/springboot/sample/configuration/SecurityConfiguration.java
package io.logto.springboot.sample.configuration;

import com.nimbusds.jose.JOSEObjectType;
import com.nimbusds.jose.proc.DefaultJOSEObjectTypeVerifier;
import com.nimbusds.jose.proc.SecurityContext;
import io.logto.springboot.sample.validator.AudienceValidator;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.oauth2.server.resource.OAuth2ResourceServerConfigurer;
import org.springframework.security.oauth2.core.DelegatingOAuth2TokenValidator;
import org.springframework.security.oauth2.core.OAuth2TokenValidator;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtValidators;
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;
import org.springframework.security.web.SecurityFilterChain;

@EnableWebSecurity
public class SecurityConfiguration {

    @Value("${logto.audience}")
    private String audience;

    @Value("${spring.security.oauth2.resourceserver.jwt.issuer-uri}")
    private String issuer;

    @Value("${spring.security.oauth2.resourceserver.jwt.jwk-set-uri}")
    private String jwksUri;

    @Bean
    public JwtDecoder jwtDecoder() {
        NimbusJwtDecoder jwtDecoder = NimbusJwtDecoder.withJwkSetUri(jwksUri)
                // The decoder should support the token type: Access Token + JWT.
                .jwtProcessorCustomizer(customizer -> customizer.setJWSTypeVerifier(
                        new DefaultJOSEObjectTypeVerifier<SecurityContext>(new JOSEObjectType("at+jwt"))))
                .build();

        jwtDecoder.setJwtValidator(new DelegatingOAuth2TokenValidator<>(
                new AudienceValidator(audience),
                new JwtIssuerValidator(issuer),
                new JwtTimestampValidator()));

        return jwtDecoder;
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http.oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt).cors().and()
                .authorizeRequests(customizer -> customizer
                        // Only authenticated requests can access your protected APIs
                        // e.g. `http://localhost:3000/` and `http://localhost:3000/profile`.
                        .mvcMatchers("/", "/secret").authenticated()
                        // Anyone can access the public profile.
                        .mvcMatchers("/profile").permitAll()
                );
        return http.build();
    }
}
```

## APIを追加する

保護されたAPIおよび公開APIを提供するためのコントローラーを追加します：

```java
// path/to/project/src/main/java/io/logto/springboot/sample/controller/ProtectedController.java
package io.logto.springboot.sample.controller;

import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

// サンプルではすべてのオリジンを許可します。
// （本番アプリケーションでは、CORSを慎重に構成する必要があります。）
@CrossOrigin(origins = "*")
@RestController
public class ProtectedController {

    @GetMapping("/")
    public String protectedRoot() {
        return "Protected root.";
    }

    @GetMapping("/secret")
    public String protectedSecret() {
        return "Protected secret.";
    }

    @GetMapping("/profile")
```java
public String publicProfile() {
    return "Public profile.";
}
```

## アクセス制限付きAPI

Spring Bootウェブアプリケーションをビルドして実行します。たとえば、`bootRun` Gradleタスクを実行してください。

<Tabs>
<TabItem value="linux-or-macos" label="LinuxまたはmacOS">

```bash
./gradlew bootRun
```

</TabItem>
<TabItem value="windows" label="Windows">

```bash
gradlew.bat bootRun
```

</TabItem>
</Tabs>

:::note

このチュートリアルでは、リクエストを行う前にAPIリソース `http://localhost:3000/` に対するアクセストークンを取得していることを前提としています。
準備ができていない場合は、続行する前に[こちら](./README.mdx#integrate-the-resources-authorization-flow-into-your-client-application)を参照してください。

:::

アクセストークンをBearerトークンとしてAuthorizationヘッダーで保護されたAPIにリクエストしてください。たとえば、`curl`コマンドを実行します。

```bash
curl --include 'http://localhost:3000/secret' \
--header 'Authorization: Bearer <your-access-token>'
```

成功した場合、200ステータスとともにレスポンスを受け取ります。

```bash
HTTP/1.1 200
...
```

そうでない場合、次のように401ステータスのレスポンスを取得します。

```bash
HTTP/1.1 401
...
WWW-Authenticate: Bearer error="invalid_token", error_description="An error occurred while attempting to decode the Jwt: Signed JWT rejected: Invalid signature", error_uri="https://tools.ietf.org/html/rfc6750#section-3.1"
...
```

## さらに読む

- [APIを保護する](./README.mdx)
- [Spring Security OAuth 2.0リソースサーバー](https://docs.spring.io/spring-security/reference/servlet/oauth2/resource-server/index.html)
- [Spring Securityアーキテクチャ](https://spring.io/guides/topicals/spring-security-architecture)