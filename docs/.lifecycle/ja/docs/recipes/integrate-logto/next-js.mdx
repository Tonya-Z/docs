---
sidebar_label: Next.js
---

import TabItem from '@theme/TabItem';
import Tabs from '@theme/Tabs';

import redirectUriFigure from './assets/next-redirect-uri.png';
import AppNote from './fragments/_app-note.mdx';
import ApplyAuthorizationToken from './fragments/_apply_authorization_token.md';
import ConfigureRedirectUri from './fragments/_configure-redirect-uri.mdx';
import FetchUserInformation from './fragments/_fetch-user-information.mdx';
import FurtherReadings from './fragments/_further-readings.md';
import GetAppSecret from './fragments/_get-app-secret.mdx';
import GetAuthorizationToken from './fragments/_get_authorization_token.md';
import UserInformationClaims from './fragments/_user-information-claims.mdx';
import AssumingUrl from './fragments/_web-assuming-url.md';
import SignInFlowSummary from './fragments/_web-sign-in-flow-summary.mdx';

# Next.js：`@logto/next`を統合

<AppNote type="伝統的なWeb" />

## Logto SDKを依存関係として追加

<Tabs>

  <TabItem value="npm" label="npm">

```bash
npm i @logto/next
```

  </TabItem>
  <TabItem value="yarn" label="Yarn">

```bash
yarn add @logto/next
```

  </TabItem>
  <TabItem value="pnpm" label="pnpm">

```bash
pnpm add @logto/next
```

  </TabItem>

</Tabs>

## LogtoClientの初期化

<AssumingUrl />

<GetAppSecret />

LogtoClientをインポートして初期化します：

```ts
// libraries/logto.ts
import LogtoClient from '@logto/next';

export const logtoClient = new LogtoClient({
  appId: '<your-application-id>',
  appSecret: '<your-app-secret-copied-from-console>',
  endpoint: '<your-logto-endpoint>', // 例：http://localhost:3001
  baseUrl: '<your-nextjs-app-base-url>', // 例：http://localhost:3000
  cookieSecret: '32文字以上の複雑なパスワード',
  cookieSecure: process.env.NODE_ENV === 'production',
});
```

## サインイン

<SignInFlowSummary />

### サインインリダイレクトURIを設定

<ConfigureRedirectUri
  figureSrc={redirectUriFigure}
  redirectUri="http://localhost:3000/api/logto/sign-in-callback"
/>

### APIルートの準備

[APIルート](https://nextjs.org/docs/api-routes/introduction)を準備して、Logtoと連携します。

IDE/エディタに戻り、最初にAPIルートを実装するために以下のコードを使用します：

```ts
// pages/api/logto/[action].ts
import { logtoClient } from '../../../libraries/logto';

export default logtoClient.handleAuthRoutes();
```

これにより、自動的に4つのルートが作成されます：

1. `/api/logto/sign-in`：Logtoでサインインします。
2. `/api/logto/sign-in-callback`：サインインのコールバックを処理します。
3. `/api/logto/sign-out`：Logtoでサインアウトします。
4. `/api/logto/user`：Logtoでユーザーが認証されているかどうかを確認します。認証されている場合、ユーザー情報を返します。

### サインインボタンの実装

ほぼ完了です！最後のステップでは、サインインボタンを作成します：

```tsx
import { useRouter } from 'next/router';

const { push } = useRouter();

<button onClick={() => push('/api/logto/sign-in')}>サインイン</button>;
```

ボタンをクリックすると、Logtoのサインインページに移動します。

## ユーザープロフィールの取得

ユーザープロフィールを取得する方法は2つあります。

### フロントエンドでのAPIリクエスト経由

`/api/logto/user`を呼び出すことで、ユーザー情報を取得できます。

```tsx
import { LogtoContext } from '@logto/next';
import useSWR from 'swr';

const Home = () => {
  const { data } = useSWR<LogtoContext>('/api/logto/user');

  return <div>userId: {data?.claims?.sub}</div>;
};

export default Profile;
```

`useSWR`については、[このガイド](https://swr.vercel.app/docs/getting-started)を参照してください。

### `getServerSideProps`を使用して

```tsx
import { LogtoContext } from '@logto/next';
import { logtoClient } from '../libraries/logto';

type Props = {
  user: LogtoContext;
};

const Profile = ({ user }: Props) => {
  return <div>ユーザーID：{user.claims?.sub}</div>;
};

export default Profile;

export const getServerSideProps = logtoClient.withLogtoSsr(async function ({ request }) {
  const { user } = request;

  return {
    props: { user },
  };
});
```

`getServerSideProps`の詳細については、[Next.jsのドキュメント](https://nextjs.org/docs/basic-features/data-fetching/get-server-side-props)を参照してください。

### ユーザー情報の取得

ほとんどのケースでは、`claims`を使用することをお勧めします。`claims`はトークンが付与されるとキャッシュされるため、高速に動作します。より正確なユーザー情報が必要な場合は、`config.fetchUserInfo`を`true`に設定して、OIDCの[UserInfo Endpoint](https://openid.net/specs/openid-connect-core-1_0.html#UserInfo)からユーザー情報を取得するようSDKに指示します。

```ts
// pages/api/logto/user-info.ts
import { logtoClient } from '../../../libraries/logto';

export default logtoClient.handleAuthRoutes({ fetchUserInfo: true });
```

<UserInformationClaims />

## APIおよびページの保護

### APIルートの保護

ハンドラを`logtoClient.withLogtoApiRoute`でラップします。

```ts
// pages/api/protected-resource.ts
import { logtoClient } from '../../libraries/logto';

export default logtoClient.withLogtoApiRoute((request, response) => {
  if (!request.user.isAuthenticated) {
    response.status(401).json({ message: '承認されていません' });

    return;
  }

  response.json({
    data: 'これは保護されたリソースです',
  });
});
```

### ページの保護

匿名ユーザーがページにアクセスできないようにする場合は、`logtoClient.withLogtoSsr`を使用して認証状態を取得し、認証されていない場合はサインインルートにリダイレクトします。

```ts
export const getServerSideProps = logtoClient.withLogtoSsr(async function ({ req, res }) {
  const { user } = req;

  if (!user.isAuthenticated) {
    res.setHeader('location', '/api/logto/sign-in');
    res.statusCode = 302;
    res.end();
  }

  return {
    props: { user },
  };
});
```

## サインアウト

`/api/logto/sign-out`を呼び出すと、メモリとクッキー内のすべてのLogtoデータが削除されます。

サインアウト後、ユーザーを元のウェブサイトにリダイレクトすると良いでしょう。管理コンソールの[リダイレクトURI](https://openid.net/specs/openid-connect-core-1_0.html#Post-logout-Redirect-URI)に`http://localhost:3000`を追加しましょう。

### サインアウトボタンの実装

```tsx
<button onClick={() => push('/api/logto/sign-out')}>サインアウト</button>
```

## ユーザー情報の取得

<FetchUserInformation apiCodeFragment="logtoClient.handleUser({ fetchUserInfo: true })" />

## バックエンドAPIの認証

<GetAuthorizationToken />

Logto SDKの設定にAPIリソースの指標を追加します：

```ts
// libraries/logto.ts
import LogtoClient from '@logto/next';

export const logtoClient = new LogtoClient({
  appId: '<your-application-id>',
  appSecret: '<your-app-secret-copied-from-console>',
  endpoint: '<your-logto-endpoint>', // 例：http://localhost:3001
  baseUrl: '<your-nextjs-app-base-url>', // 例：http://localhost:3000
  cookieSecret: '32文字以上の複雑なパスワード',
  cookieSecure: process.env.NODE_ENV === 'production',
  resources: ['<your-api-resource>'],
});
```

APIルートを作成する際にリソースを指定します：

```ts
// pages/api/logto/[action].ts
import { logtoClient } from '../../../libraries/logto';

export default logtoClient.handleAuthRoutes({ resource: '<your-target-api-resource>' });
```

`logtoClient.withLogtoApiRoute`内から認可トークンを取得します：

```ts
// pages/api/protected-resource.ts
import { logtoClient } from '../../libraries/logto';

export default logtoClient.withLogtoApiRoute(
  (request, response) => {
    if (!request.user.isAuthenticated) {
      response.status(401).json({ message: '承認されていません' });

      return;
    }

    // アクセストークンはrequest.user.accessTokenから取得できます

    response.json({
      data: 'これは保護されたリソースです',
    });
  },
  { getAccessToken: true, resource: '<your-target-api-resource>' }
);
```

また、`getServerSideProps`内からもアクセストークンを取得できます：

```tsx
import { LogtoContext } from '@logto/next';
import { logtoClient } from '../libraries/logto';

type Props = {
  user: LogtoContext;
};

const Profile = ({ user }: Props) => {
```jsx
return <div>User ID: {user.claims?.sub}</div>;
};

export default Profile;

export const getServerSideProps = logtoClient.withLogtoSsr(
  async function ({ req }) {
    const { user } = req;

    // ユーザーアクセス トークンは user.accessToken から取得できます

    return {
      props: { user },
    };
  },
  { getAccessToken: true, resource: '<あなたのターゲットAPIリソース>' }
);
```

<ApplyAuthorizationToken />

## さらなる読み物

<FurtherReadings />
```