```markdown
      + {R}
      + {R}
      + {R}
      + {R}
      + {R}
      + {R}
          + {R}
      + {R}
          + {R}
      + {R}
          + {R}
      + {R}
              + {R}
          + {R}
          + {R}
          + {R}
          + {R}
      + {R}
              + {R}
          + {R}
              + {R}
          + {R}
      + {R}
              + {R}
          + {R}
      + {R}
      + {R}
      + {R}
          + {R}
      + {R}
          + {R}
              + {R}
                  + {R}
          + {R}
      + {R}
          + {R}
          + {R}
      + {R}
      + {R}
      + {R}
          + {R}
          + {R}
          + {R}
              + {R}
          + {R}
          + {R}
      + {R}
  + {R}
  + {R}
      + {R}
          + {R}
      + {R}
          + {R}
      + {R}
  + {R}
```
```markdown
```
`<div><a href="/sign-out">Sign Out</a></div>`

ctx.Data(http.StatusOK, "text/html; charset=utf-8", []byte(homePage))
})

// ログアウトリクエストを処理するためのルートを追加
router.GET("/sign-out", func(ctx *gin.Context) {
    session := sessions.Default(ctx)
    logtoClient := client.NewLogtoClient(
        logtoConfig,
        &SessionStorage{session: session},
    )

    // サインアウトリクエストはLogtoによって処理されます。
    // ユーザーはサインアウト時にPost Sign-out Redirect URIにリダイレクトされます。
    signOutUri, signOutErr := logtoClient.SignOut("http://localhost:8080")

    if signOutErr != nil {
        ctx.String(http.StatusOK, signOutErr.Error())
        return
    }

    ctx.Redirect(http.StatusTemporaryRedirect, signOutUri)
})

// ...
}
```

ユーザーがログアウトリクエストを行うと、Logtoはセッション内のすべてのユーザー認証情報をクリアします。

## ユーザー情報の取得

<FetchUserInformation apiCodeFragment="logtoClient.FetchUserInfo()" />

## さらなる読み物

<FurtherReadings />
```